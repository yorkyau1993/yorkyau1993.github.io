<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <title>7æ—¥å¤©æ°£é»ƒæ›†ç·¨è¼¯å™¨</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@900&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans TC', sans-serif; background: #1a1a1a; color: white; padding: 20px; margin: 0; display: flex; flex-direction: column; align-items: center; }
        .global-controls { 
            background: #333; padding: 15px 30px; border-radius: 50px; 
            margin-bottom: 30px; position: sticky; top: 10px; z-index: 1000;
            display: flex; gap: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); align-items: center;
        }
        .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(360px, 1fr)); gap: 25px; width: 100%; max-width: 1400px; }
        .card { background: #262626; padding: 15px; border-radius: 20px; border: 1px solid #333; display: flex; flex-direction: column; }
        canvas { 
            width: 100%; height: auto; border-radius: 10px; cursor: move; touch-action: none;
            background-image: linear-gradient(45deg, #333 25%, transparent 25%), linear-gradient(-45deg, #333 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #333 75%), linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px; border: 1px solid #444; margin-bottom: 10px;
        }
        .input-group { display: flex; flex-direction: column; gap: 5px; }
        input, textarea { background: #111; color: white; border: 1px solid #444; padding: 8px; border-radius: 5px; width: 100%; box-sizing: border-box; font-family: inherit; font-weight: bold; }
        textarea { height: 45px; resize: none; }
        .btn-group { display: flex; gap: 8px; margin-top: 10px; }
        button { flex: 1; padding: 10px; border-radius: 5px; border: none; font-weight: bold; cursor: pointer; transition: 0.2s; }
        .dl-btn { background: #444; color: white; }
        .pp-btn { background: #18d363; color: black; }
    </style>
</head>
<body>

    <div class="global-controls">
        <div><label>ğŸŒ“ é™°å½± </label><input type="range" id="gShadow" min="0" max="60" value="35" oninput="drawAll()"></div>
        <div><label>ğŸ–‹ï¸ å¤–æ¡† </label><input type="range" id="gStroke" min="0" max="25" value="12" oninput="drawAll()"></div>
    </div>

    <div id="weatherGrid" class="grid">æ­£åœ¨æŠ“å–é¦™æ¸¯å¤©æ–‡å°æ•¸æ“š...</div>

    <script>
        const HKO_API = 'https://data.weather.gov.hk/weatherAPI/opendata/weather.php?dataType=fnd&lang=tc';
        let items = [];

        async function init() {
            try {
                const res = await fetch(HKO_API);
                const data = await res.json();
                const forecast = data.weatherForecast.slice(0, 7);
                
                forecast.forEach((day, i) => {
                    const minT = typeof day.forecastMintemp === 'object' ? day.forecastMintemp.value : day.forecastMintemp;
                    const maxT = typeof day.forecastMaxtemp === 'object' ? day.forecastMaxtemp.value : day.forecastMaxtemp;
                    const cleanWeather = day.forecastWeather.replace(/[ï¼ˆï¼‰()]/g, '').trim();

                    items.push({
                        date: { text: `${day.forecastDate.substring(4,6)}æœˆ${day.forecastDate.substring(6,8)}æ—¥ ${day.week}`, x: 80, y: 150, w: 550, h: 80, size: 85, color: "white" },
                        temp: { text: `${minT}Â°-${maxT}Â°C`, x: 80, y: 350, w: 650, h: 180, size: 220, color: "#ffde06" },
                        desc: { text: cleanWeather, x: 80, y: 480, w: 850, h: 100, size: 70, color: "white" },
                        good: { text: "å®œï¼šå¸¶å®‰å…¨å¸¶", x: 80, y: 750, w: 600, h: 120, size: 105, color: "#18d363" },
                        bad: { text: "å¿Œï¼šè²ªæ±¡æ”¾ä¸Šç¶²", x: 80, y: 920, w: 750, h: 120, size: 105, color: "#ff4444" },
                        dragging: null, offset: { x: 0, y: 0 }
                    });
                });
                renderUI();
            } catch (e) { document.getElementById('weatherGrid').innerText = "æ•¸æ“šè¼‰å…¥å¤±æ•—ã€‚"; }
        }

        function renderUI() {
            const grid = document.getElementById('weatherGrid');
            grid.innerHTML = '';
            items.forEach((item, i) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
                    <canvas id="cvs-${i}" width="1080" height="1080"></canvas>
                    <div class="input-group">
                        <input type="text" value="${item.date.text}" oninput="items[${i}].date.text=this.value; draw(${i})">
                        <input type="text" value="${item.temp.text}" oninput="items[${i}].temp.text=this.value; draw(${i})">
                        <textarea oninput="items[${i}].desc.text=this.value; draw(${i})">${item.desc.text}</textarea>
                        <input type="text" value="${item.good.text}" style="color:#18d363" oninput="items[${i}].good.text=this.value; draw(${i})">
                        <input type="text" value="${item.bad.text}" style="color:#ff4444" oninput="items[${i}].bad.text=this.value; draw(${i})">
                    </div>
                    <div class="btn-group">
                        <button class="dl-btn" onclick="downloadPNG(${i})">ä¸‹è¼‰ PNG</button>
                        <button class="pp-btn" onclick="openPhotopea(${i})">Photopea</button>
                    </div>
                `;
                grid.appendChild(card);
                setupDrag(i);
            });
            setTimeout(drawAll, 600);
        }

        function setupDrag(i) {
            const cvs = document.getElementById(`cvs-${i}`);
            cvs.onmousedown = (e) => {
                const rect = cvs.getBoundingClientRect();
                const mx = (e.clientX - rect.left) * (1080 / rect.width);
                const my = (e.clientY - rect.top) * (1080 / rect.height);
                const keys = ['bad', 'good', 'desc', 'temp', 'date'];
                for (let key of keys) {
                    const o = items[i][key];
                    if (mx >= o.x - 20 && mx <= o.x + o.w && my >= o.y - o.h && my <= o.y + 20) {
                        items[i].dragging = key;
                        items[i].offset.x = mx - o.x;
                        items[i].offset.y = my - o.y;
                        return;
                    }
                }
            };
            window.addEventListener('mousemove', (e) => {
                const idx = items.findIndex(it => it.dragging !== null);
                if (idx === -1) return;
                const state = items[idx];
                const activeCvs = document.getElementById(`cvs-${idx}`);
                const rect = activeCvs.getBoundingClientRect();
                const mx = (e.clientX - rect.left) * (1080 / rect.width);
                const my = (e.clientY - rect.top) * (1080 / rect.height);
                state[state.dragging].x = mx - state.offset.x;
                state[state.dragging].y = my - state.offset.y;
                draw(idx);
            });
            window.addEventListener('mouseup', () => {
                items.forEach(it => it.dragging = null);
                drawAll();
            });
        }

        function draw(i) {
            const canvas = document.getElementById(`cvs-${i}`);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const state = items[i];
            const shadow = document.getElementById('gShadow').value;
            const stroke = document.getElementById('gStroke').value;

            ctx.clearRect(0, 0, 1080, 1080);
            ctx.textAlign = "left";
            ctx.lineJoin = "round";
            ctx.shadowColor = "black";
            ctx.shadowBlur = shadow;
            ctx.strokeStyle = "black";
            ctx.lineWidth = stroke;

            const render = (obj) => {
                ctx.font = `900 ${obj.size}px 'Noto Sans TC'`;
                ctx.fillStyle = obj.color;
                const lines = obj.text.split('\n');
                lines.forEach((line, idx) => {
                    const ty = obj.y + (idx * obj.size * 1.1);
                    ctx.strokeText(line, obj.x, ty);
                    ctx.fillText(line, obj.x, ty);
                });
            };

            render(state.date);
            render(state.temp);
            render(state.desc);
            render(state.good);
            render(state.bad);

            if (state.dragging) {
                ctx.shadowBlur = 0; ctx.strokeStyle = "#0084ff"; ctx.lineWidth = 4;
                const o = state[state.dragging];
                ctx.strokeRect(o.x - 10, o.y - o.h, o.w + 20, o.h + 40);
            }
        }

        function drawAll() { items.forEach((_, i) => draw(i)); }
        function downloadPNG(i) {
            const link = document.createElement('a');
            link.download = `HKO-Layer-${i+1}.png`;
            link.href = document.getElementById(`cvs-${i}`).toDataURL();
            link.click();
        }
        function openPhotopea(i) { downloadPNG(i); window.open("https://www.photopea.com", "_blank"); }

        window.onload = init;
    </script>
</body>
</html>
